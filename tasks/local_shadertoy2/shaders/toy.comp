#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;


const vec3  eye      = vec3 ( 0, 0, 10 );
const vec3  light    = vec3  ( 0.0, 6.0, 5.0 );
const int   maxSteps = 70;
const float eps      = 0.01;
const float maxDist  = 15.0;
const float iGlobalTime = 0.0;


float smin(float a, float b, float k) {
    float h = max(k - abs(a - b), 0.0) / k;
    return min(a, b) - h * h * h * k * (1.0 / 6.0);
}

mat4 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat4(
        vec4(1, 0, 0, 0),
        vec4(0, c, -s, 0),
        vec4(0, s, c, 0),
        vec4(0, 0, 0, 1)
    );
}

mat4 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat4(
        vec4(c, 0, s, 0),
        vec4(0, 1, 0, 0),
        vec4(-s, 0, c, 0),
        vec4(0, 0, 0, 1)
    );
}

mat4 translate(vec3 offs){
    return mat4(
        vec4(1, 0, 0, 0),
        vec4(0, 1, 0, 0),
        vec4(0, 0, 1, 0),
        vec4(offs.x, offs.y, offs.z, 1)
        );
}

vec3 transformPoint(in mat4 m, in vec3 v) {
    return (m * vec4(v, 1)).xyz;
}

vec3 transformVector(in mat4 m, in vec3 v) {
    return (m * vec4(v, 0)).xyz;
}

float sdRoundedCylinder(vec3 p, float ra, float rb, float h) {
    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;
}

float dTorus(vec3 p, vec2 t) {
    vec2 q = vec2(length(p.xz) - t.x, p.y);
    return length(q) - t.y;
}

float dSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdfPlane(vec3 p, vec4 n) {
    return dot(p, n.xyz) + n.w;
}

vec2 sdf(in vec3 p) { 

    const float ORBIT_RADIUS = 2.0;
    const float SMOOTH_FACTOR = 1.0;
    const vec4 PLANE_NORMAL = vec4(0.0, 0.34, 0.0, 1.0);

    float moveSpeed = sin(iTime * 1.5) * 2.4;
    float orbitAngle = iTime;
    float ballHeight = sin(iTime) * 1.5;

    // Positions
    vec3 spherePos = vec3(0.0, moveSpeed, 0.0);
    vec3 torusPos = ORBIT_RADIUS * vec3(cos(orbitAngle), 0.0, sin(orbitAngle));
    vec3 ballPos = torusPos + vec3(0.0, ballHeight, 0.0);

    float cylinderSdf = sdRoundedCylinder(p, 0.5, 0.2, 0.8);
    float sphereSdf = dSphere(p - spherePos, 0.6);
    float torusSdf = dTorus(p - torusPos, vec2(0.6, 0.15));
    float ballSdf = dSphere(p - ballPos, 0.2);
    float planeSdf = sdfPlane(p, PLANE_NORMAL);

    float blendedSdf = smin(cylinderSdf, sphereSdf, SMOOTH_FACTOR);

    float minSdf = min(blendedSdf, min(planeSdf, min(torusSdf, ballSdf)));
    float id;

    if (minSdf == blendedSdf) {
        id = (cylinderSdf < sphereSdf) ? 1.0 : 2.0;
    } else if (minSdf == planeSdf) {
        id = 3.0;
    } else if (minSdf == torusSdf) {
        id = 4.0;
    } else {
        id = 5.0;
    }

    return vec2(minSdf, id);
}

vec3 trace(in vec3 from, in vec3 dir, out bool hit, out float id) {
    vec3 p = from;
    float totalDist = 0.0;
    id = -1.0;
    hit = false;

    for (int steps = 0; steps < maxSteps; steps++) {
        vec2 distAndID = sdf(p);
        float dist = abs(distAndID.x);
        
        if (dist < eps) {
            hit = true;
            id = distAndID.y; 
            break;
        }
        
        totalDist += dist;
        if (totalDist > maxDist) {
            break;
        }
        p += dist * dir; 
    }
    return p;
}


vec3 generateNormal(vec3 z) {
    float e = max(0.01, eps);
    float dx1 = sdf(z + vec3(e, 0, 0)).x;
    float dx2 = sdf(z - vec3(e, 0, 0)).x;
    float dy1 = sdf(z + vec3(0, e, 0)).x;
    float dy2 = sdf(z - vec3(0, e, 0)).x;
    float dz1 = sdf(z + vec3(0, 0, e)).x;
    float dz2 = sdf(z - vec3(0, 0, e)).x;

    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));
}

void main()
{
    ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

    bool hit;
    float id;

    vec3 cEye = vec3(0, 0, 10);
    // vec3 mouse = vec3(iMouse.xy / iResolution.xy - 0.5, iMouse.z - 0.5);
    mat3 m = rotateX(6.0 * 0.0) * rotateY(6.0 * 0.0);
    
    vec2 scale = 9.0 * vec2(1280, 720) / 1280;
    vec2 uv = scale * (vec2(fragCoord) / vec2(1280, 720) - vec2(0.5));
    uv.y = -uv.y;
    vec3 dir = normalize(vec3(uv, 0) - eye);
   
    vec3 p = trace(eye, dir, hit, id, m);  
    
    vec3 color = vec3(0.91, 0.91, 0.93);
    
    vec3 l = normalize(light - p);
    vec3 v = normalize(eye - p);
    vec3 n = generateNormal(p, 0.001, m);
    vec3 h = normalize(l + v);
    
    float nl = max(0.0, dot(n, l));
    float sp = pow(max(0.0, dot(h, n)), 150.0);


    if (hit) {

        vec3 objColor;
        if (id == 1.0) {
            objColor = vec3(0.8, 0.4, 0.0); // Cylinder 
        } else if (id == 4.0) {
            objColor = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0),
                           p.y * 0.5 + 0.5) * (1.0 - (p.y * 0.5 + 0.5) * (p.y * 0.5 + 0.5)); //Circle big
        } else if (id == 2.0) {
            objColor = vec3(0, 0.5, 1); // Torus 
        } else if (id == 3.0) {
            objColor = vec3(0.8, 0.4, 0.0); // Circle small 
        }

        // Lighting model
        int lightingModel = 1;
        switch (lightingModel) {
            case 0: // Lambert
                color = objColor * nl;
                break;
            case 1: // Lambert + Phong
                color = objColor * nl + 3.5 * sp * vec3(1, 1, 1);
                break;
        }
    }

  vec4 fragColor = vec4(color, 1.0);

  if (fragCoord.x < 1280 && fragCoord.y < 720)
    imageStore(resultImage, fragCoord, fragColor);
}